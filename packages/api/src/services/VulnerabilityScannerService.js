const winston = require('winston');
const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'vulnerability-scanner' },
  transports: [
    new winston.transports.File({ filename: 'logs/vulnerability-scanner-error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/vulnerability-scanner-combined.log' })
  ]
});

class VulnerabilityScannerService {
  constructor() {
    this.vulnerabilityDatabase = this.initializeVulnerabilityDatabase();
    this.scanResults = new Map();
    this.riskAssessmentRules = this.initializeRiskAssessment();
    this.remediationSuggestions = this.initializeRemediationSuggestions();
  }

  initializeVulnerabilityDatabase() {
    return {
      // OWASP Top 10 vulnerabilities
      owasp: {
        injection: {
          description: 'Injection flaws occur when untrusted data is sent to an interpreter',
          severity: 'critical',
          cwe: ['CWE-79', 'CWE-89', 'CWE-73'],
          patterns: [
            /\$\{.*\}/, // Template injection
            /eval\s*\(/, // Code injection
            /javascript:/i, // XSS
            /union\s+select/i // SQL injection
          ]
        },
        brokenAuthentication: {
          description: 'Authentication mechanisms that can be bypassed',
          severity: 'critical',
          cwe: ['CWE-287', 'CWE-384', 'CWE-521'],
          patterns: [
            /password.*=.*['"]\s*['"]/, // Empty passwords
            /admin.*password/i, // Default credentials
            /hardcoded.*password/i // Hardcoded passwords
          ]
        },
        sensitiveDataExposure: {
          description: 'Sensitive data not properly protected',
          severity: 'high',
          cwe: ['CWE-200', 'CWE-312', 'CWE-313'],
          patterns: [
            /password.*=.*['"][^'"]{0,6}['"]/, // Weak passwords
            /api[_-]?key.*=.*['"][a-zA-Z0-9]{1,16}['"]/, // Weak API keys
            /database.*password/i // Database credentials
          ]
        },
        xmlExternalEntities: {
          description: 'XML processors vulnerable to XXE attacks',
          severity: 'high',
          cwe: ['CWE-611'],
          patterns: [
            /<\!ENTITY/i,
            /SYSTEM\s+["'][^"']*["']/i,
            /PUBLIC\s+["'][^"']*["']\s+["'][^"']*["']/i
          ]
        },
        brokenAccessControl: {
          description: 'Restrictions on authenticated users are not properly enforced',
          severity: 'high',
          cwe: ['CWE-22', 'CWE-284', 'CWE-285'],
          patterns: [
            /\.\.\//, // Path traversal
            /admin.*role.*=.*false/i, // Role manipulation
            /delete.*user.*id=\d+/i // IDOR
          ]
        },
        securityMisconfiguration: {
          description: 'Security configurations not properly configured',
          severity: 'medium',
          cwe: ['CWE-16', 'CWE-611'],
          patterns: [
            /debug\s*=\s*true/i, // Debug mode enabled
            /error.*reporting.*on/i, // Error reporting enabled
            /directory.*listing.*on/i // Directory listing enabled
          ]
        },
        crossSiteScripting: {
          description: 'XSS flaws occur when untrusted data is included in web pages',
          severity: 'high',
          cwe: ['CWE-79'],
          patterns: [
            /<script[^>]*>.*?<\/script>/gi,
            /on\w+\s*=\s*["']?[^"']*["']?/gi,
            /<iframe[^>]*>.*?<\/iframe>/gi
          ]
        },
        insecureDeserialization: {
          description: 'Deserialization of untrusted data',
          severity: 'high',
          cwe: ['CWE-502'],
          patterns: [
            /serialize.*untrusted/i,
            /deserialize.*user/i,
            /pickle\.loads/i
          ]
        },
        usingComponentsWithKnownVulnerabilities: {
          description: 'Using components with known vulnerabilities',
          severity: 'medium',
          cwe: ['CWE-937'],
          patterns: [
            /jquery.*1\.[0-6]/i, // Old jQuery versions
            /bootstrap.*3\.[0-3]/i, // Old Bootstrap versions
            /lodash.*3\./i // Old Lodash versions
          ]
        },
        insufficientLogging: {
          description: 'Insufficient logging and monitoring',
          severity: 'medium',
          cwe: ['CWE-778'],
          patterns: [
            /console\.log.*password/i, // Logging passwords
            /log.*user.*password/i, // Logging user passwords
            /debug.*password/i // Debug logging passwords
          ]
        }
      },
      
      // Additional vulnerability categories
      additional: {
        commandInjection: {
          description: 'Command injection vulnerabilities',
          severity: 'critical',
          cwe: ['CWE-77', 'CWE-78'],
          patterns: [
            /exec\s*\(/,
            /system\s*\(/,
            /shell_exec\s*\(/,
            /passthru\s*\(/
          ]
        },
        ldapInjection: {
          description: 'LDAP injection vulnerabilities',
          severity: 'high',
          cwe: ['CWE-90'],
          patterns: [
            /\*[\(\)\\\|&=]/,
            /\b(and|or|not)\b.*\*/i
          ]
        },
        nosqlInjection: {
          description: 'NoSQL injection vulnerabilities',
          severity: 'high',
          cwe: ['CWE-943'],
          patterns: [
            /\$where/i,
            /\$ne/,
            /\$gt.*\$lt/,
            /\$regex.*\$options/
          ]
        },
        serverSideRequestForgery: {
          description: 'Server-Side Request Forgery (SSRF)',
          severity: 'high',
          cwe: ['CWE-918'],
          patterns: [
            /http:\/\/localhost/i,
            /file:\/\//i,
            /http:\/\/127\.0\.0\.1/i,
            /http:\/\/0\.0\.0\.0/i
          ]
        },
        pathTraversal: {
          description: 'Path traversal vulnerabilities',
          severity: 'high',
          cwe: ['CWE-22', 'CWE-23'],
          patterns: [
            /\.\.\//,
            /%2e%2e%2f/,
            /\.\.\\/,
            /%2e%2e%5c/
          ]
        }
      }
    };
  }

  initializeRiskAssessment() {
    return {
      severity: {
        critical: { score: 10, color: '#d32f2f', action: 'immediate' },
        high: { score: 7, color: '#f57c00', action: 'urgent' },
        medium: { score: 5, color: '#fbc02d', action: 'planned' },
        low: { score: 3, color: '#689f38', action: 'monitor' },
        info: { score: 1, color: '#0288d1', action: 'document' }
      },
      
      impact: {
        confidentiality: { high: 3, medium: 2, low: 1, none: 0 },
        integrity: { high: 3, medium: 2, low: 1, none: 0 },
        availability: { high: 3, medium: 2, low: 1, none: 0 }
      },
      
      likelihood: {
        very_high: 5,
        high: 4,
        medium: 3,
        low: 2,
        very_low: 1
      }
    };
  }

  initializeRemediationSuggestions() {
    return {
      injection: {
        description: 'Use parameterized queries and input validation',
        steps: [
          'Implement prepared statements for all database queries',
          'Use ORM with built-in protection against SQL injection',
          'Validate and sanitize all user inputs',
          'Implement least privilege for database access'
        ],
        tools: ['ESLint security plugins', 'SQLMap', 'Burp Suite'],
        resources: ['OWASP SQL Injection Prevention Cheat Sheet']
      },
      
      brokenAuthentication: {
        description: 'Implement strong authentication mechanisms',
        steps: [
          'Use multi-factor authentication (MFA)',
          'Implement account lockout mechanisms',
          'Use secure session management',
          'Implement proper password policies'
        ],
        tools: ['OWASP ZAP', 'Nmap', 'Metasploit'],
        resources: ['OWASP Authentication Cheat Sheet']
      },
      
      sensitiveDataExposure: {
        description: 'Encrypt sensitive data at rest and in transit',
        steps: [
          'Use HTTPS for all communications',
          'Encrypt sensitive data at rest',
          'Implement proper key management',
          'Use strong encryption algorithms'
        ],
        tools: ['SSL Labs', 'OpenSSL', 'Wireshark'],
        resources: ['OWASP Cryptographic Storage Cheat Sheet']
      },
      
      xss: {
        description: 'Prevent cross-site scripting attacks',
        steps: [
          'Encode output based on context',
          'Use Content Security Policy (CSP)',
          'Validate and sanitize all user inputs',
          'Use security-focused frameworks'
        ],
        tools: ['XSS Hunter', 'Burp Suite', 'OWASP ZAP'],
        resources: ['OWASP XSS Prevention Cheat Sheet']
      }
    };
  }

  // Main vulnerability scanning function
  async scanCodebase(codebasePath, options = {}) {
    const {
      scanDepth = 'deep',
      includeDependencies = true,
      generateReport = true,
      maxFileSize = '1mb'
    } = options;

    logger.info(`Starting vulnerability scan of ${codebasePath}`);
    
    const scanId = this.generateScanId();
    const startTime = Date.now();
    
    try {
      const scanResults = {
        scanId,
        startTime,
        codebasePath,
        options,
        vulnerabilities: [],
        summary: {
          totalFiles: 0,
          totalVulnerabilities: 0,
          critical: 0,
          high: 0,
          medium: 0,
          low: 0,
          info: 0
        },
        dependencies: [],
        recommendations: []
      };

      // Scan source code files
      const codeFiles = await this.findCodeFiles(codebasePath);
      scanResults.summary.totalFiles = codeFiles.length;
      
      for (const filePath of codeFiles) {
        try {
          const fileResults = await this.scanFile(filePath, maxFileSize);
          if (fileResults.vulnerabilities.length > 0) {
            scanResults.vulnerabilities.push(...fileResults.vulnerabilities);
          }
        } catch (error) {
          logger.error(`Error scanning file ${filePath}:`, error);
        }
      }

      // Scan dependencies if requested
      if (includeDependencies) {
        const dependencyResults = await this.scanDependencies(codebasePath);
        scanResults.dependencies = dependencyResults;
      }

      // Generate summary statistics
      scanResults.summary = this.generateSummary(scanResults.vulnerabilities);
      
      // Generate recommendations
      scanResults.recommendations = this.generateRecommendations(scanResults.vulnerabilities);
      
      // Calculate risk score
      scanResults.riskScore = this.calculateRiskScore(scanResults.vulnerabilities);
      
      // Generate detailed report
      if (generateReport) {
        scanResults.detailedReport = await this.generateDetailedReport(scanResults);
      }

      scanResults.endTime = Date.now();
      scanResults.duration = scanResults.endTime - startTime;
      
      // Store scan results
      this.scanResults.set(scanId, scanResults);
      
      logger.info(`Vulnerability scan completed. Found ${scanResults.summary.totalVulnerabilities} vulnerabilities`);
      
      return scanResults;
      
    } catch (error) {
      logger.error('Vulnerability scan failed:', error);
      throw error;
    }
  }

  async findCodeFiles(codebasePath) {
    const codeExtensions = ['.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.php', '.rb', '.go'];
    const files = [];
    
    async function walkDirectory(dir) {
      const entries = await fs.readdir(dir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        
        if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {
          await walkDirectory(fullPath);
        } else if (entry.isFile() && codeExtensions.some(ext => entry.name.endsWith(ext))) {
          files.push(fullPath);
        }
      }
    }
    
    await walkDirectory(codebasePath);
    return files;
  }

  async scanFile(filePath, maxFileSize) {
    const stats = await fs.stat(filePath);
    const maxSizeBytes = this.parseFileSize(maxFileSize);
    
    if (stats.size > maxSizeBytes) {
      logger.warn(`File ${filePath} exceeds maximum size limit, skipping`);
      return { vulnerabilities: [] };
    }
    
    const content = await fs.readFile(filePath, 'utf8');
    const vulnerabilities = [];
    
    // Scan for each vulnerability category
    for (const [category, vulnData] of Object.entries(this.vulnerabilityDatabase.owasp)) {
      const categoryResults = this.scanForVulnerability(content, category, vulnData, filePath);
      vulnerabilities.push(...categoryResults);
    }
    
    for (const [category, vulnData] of Object.entries(this.vulnerabilityDatabase.additional)) {
      const categoryResults = this.scanForVulnerability(content, category, vulnData, filePath);
      vulnerabilities.push(...categoryResults);
    }
    
    return { vulnerabilities };
  }

  scanForVulnerability(content, category, vulnData, filePath) {
    const vulnerabilities = [];
    const lines = content.split('\n');
    
    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
      const line = lines[lineNumber];
      
      for (const pattern of vulnData.patterns) {
        const matches = line.match(pattern);
        if (matches) {
          vulnerabilities.push({
            category: category,
            severity: vulnData.severity,
            description: vulnData.description,
            cwe: vulnData.cwe,
            file: filePath,
            line: lineNumber + 1,
            code: line.trim(),
            match: matches[0],
            confidence: this.calculateConfidence(matches[0], pattern),
            remediation: this.getRemediationSuggestion(category)
          });
        }
      }
    }
    
    return vulnerabilities;
  }

  calculateConfidence(match, pattern) {
    // Simple confidence calculation based on match length and pattern specificity
    const matchLength = match.length;
    const patternString = pattern.toString();
    const patternComplexity = patternString.length;
    
    if (matchLength > 10 && patternComplexity > 20) return 'high';
    if (matchLength > 5 && patternComplexity > 10) return 'medium';
    return 'low';
  }

  getRemediationSuggestion(category) {
    return this.remediationSuggestions[category] || {
      description: 'Review code for security issues',
      steps: ['Manual code review required'],
      tools: ['Manual review'],
      resources: ['OWASP Security Guidelines']
    };
  }

  async scanDependencies(codebasePath) {
    const dependencies = [];
    
    try {
      // Scan package.json
      const packageJsonPath = path.join(codebasePath, 'package.json');
      const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));
      
      if (packageJson.dependencies) {
        for (const [name, version] of Object.entries(packageJson.dependencies)) {
          dependencies.push({
            name,
            version,
            type: 'dependency',
            vulnerabilities: await this.checkDependencyVulnerabilities(name, version)
          });
        }
      }
      
      if (packageJson.devDependencies) {
        for (const [name, version] of Object.entries(packageJson.devDependencies)) {
          dependencies.push({
            name,
            version,
            type: 'devDependency',
            vulnerabilities: await this.checkDependencyVulnerabilities(name, version)
          });
        }
      }
      
    } catch (error) {
      logger.warn('Could not scan dependencies:', error);
    }
    
    return dependencies;
  }

  async checkDependencyVulnerabilities(name, version) {
    // This is a simplified implementation
    // In a real implementation, you would integrate with vulnerability databases
    const knownVulnerablePackages = {
      'lodash': ['3.0.0', '3.1.0', '3.2.0'],
      'jquery': ['1.0.0', '1.1.0', '1.2.0'],
      'express': ['3.0.0', '3.1.0']
    };
    
    const vulnerabilities = [];
    
    if (knownVulnerablePackages[name] && knownVulnerablePackages[name].includes(version)) {
      vulnerabilities.push({
        id: `${name}-${version}-vuln`,
        severity: 'high',
        description: `Known vulnerability in ${name}@${version}`,
        recommendation: `Update ${name} to latest version`
      });
    }
    
    return vulnerabilities;
  }

  generateSummary(vulnerabilities) {
    const summary = {
      totalFiles: 0,
      totalVulnerabilities: vulnerabilities.length,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0
    };
    
    vulnerabilities.forEach(vuln => {
      summary[vuln.severity] = (summary[vuln.severity] || 0) + 1;
    });
    
    return summary;
  }

  generateRecommendations(vulnerabilities) {
    const categories = new Set(vulnerabilities.map(v => v.category));
    const recommendations = [];
    
    categories.forEach(category => {
      const remediation = this.remediationSuggestions[category];
      if (remediation) {
        recommendations.push({
          category,
          description: remediation.description,
          steps: remediation.steps,
          tools: remediation.tools,
          resources: remediation.resources
        });
      }
    });
    
    return recommendations;
  }

  calculateRiskScore(vulnerabilities) {
    if (vulnerabilities.length === 0) return 0;
    
    const severityScores = {
      critical: 10,
      high: 7,
      medium: 5,
      low: 3,
      info: 1
    };
    
    const totalScore = vulnerabilities.reduce((sum, vuln) => {
      return sum + (severityScores[vuln.severity] || 0);
    }, 0);
    
    const maxPossibleScore = vulnerabilities.length * 10;
    return Math.round((totalScore / maxPossibleScore) * 100);
  }

  async generateDetailedReport(scanResults) {
    return {
      executiveSummary: this.generateExecutiveSummary(scanResults),
      detailedFindings: scanResults.vulnerabilities,
      riskAssessment: this.generateRiskAssessment(scanResults),
      remediationPlan: this.generateRemediationPlan(scanResults),
      complianceCheck: this.generateComplianceCheck(scanResults)
    };
  }

  generateExecutiveSummary(scanResults) {
    const { summary, riskScore } = scanResults;
    
    return {
      totalVulnerabilities: summary.totalVulnerabilities,
      riskScore,
      riskLevel: this.getRiskLevel(riskScore),
      criticalIssues: summary.critical,
      recommendation: this.getExecutiveRecommendation(summary, riskScore)
    };
  }

  getRiskLevel(score) {
    if (score >= 80) return 'critical';
    if (score >= 60) return 'high';
    if (score >= 40) return 'medium';
    if (score >= 20) return 'low';
    return 'minimal';
  }

  getExecutiveRecommendation(summary, riskScore) {
    if (summary.critical > 0) {
      return 'Immediate action required: Critical vulnerabilities detected';
    } else if (summary.high > 5 || riskScore > 70) {
      return 'High priority: Address vulnerabilities within 30 days';
    } else if (summary.medium > 10 || riskScore > 40) {
      return 'Medium priority: Address vulnerabilities within 90 days';
    } else {
      return 'Low priority: Regular maintenance recommended';
    }
  }

  generateRiskAssessment(scanResults) {
    const vulnerabilities = scanResults.vulnerabilities;
    
    return {
      overallRisk: this.calculateRiskScore(vulnerabilities),
      categoryBreakdown: this.getCategoryBreakdown(vulnerabilities),
      businessImpact: this.assessBusinessImpact(vulnerabilities),
      likelihood: this.assessLikelihood(vulnerabilities)
    };
  }

  getCategoryBreakdown(vulnerabilities) {
    const breakdown = {};
    vulnerabilities.forEach(vuln => {
      breakdown[vuln.category] = (breakdown[vuln.category] || 0) + 1;
    });
    return breakdown;
  }

  assessBusinessImpact(vulnerabilities) {
    const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
    const highCount = vulnerabilities.filter(v => v.severity === 'high').length;
    
    if (criticalCount > 0) return 'severe';
    if (highCount > 5) return 'significant';
    if (highCount > 0) return 'moderate';
    return 'minimal';
  }

  assessLikelihood(vulnerabilities) {
    const hasCritical = vulnerabilities.some(v => v.severity === 'critical');
    const hasHigh = vulnerabilities.some(v => v.severity === 'high');
    
    if (hasCritical) return 'very_high';
    if (hasHigh) return 'high';
    return 'medium';
  }

  generateRemediationPlan(scanResults) {
    const { vulnerabilities, recommendations } = scanResults;
    
    return {
      immediateActions: this.getImmediateActions(vulnerabilities),
      shortTermActions: this.getShortTermActions(vulnerabilities),
      longTermActions: this.getLongTermActions(vulnerabilities),
      resourceRequirements: this.estimateResourceRequirements(vulnerabilities),
      timeline: this.generateRemediationTimeline(vulnerabilities)
    };
  }

  getImmediateActions(vulnerabilities) {
    return vulnerabilities
      .filter(v => v.severity === 'critical')
      .map(v => ({
        vulnerability: v.category,
        action: v.remediation.steps[0] || 'Manual review required',
        priority: 'immediate'
      }));
  }

  getShortTermActions(vulnerabilities) {
    return vulnerabilities
      .filter(v => v.severity === 'high')
      .slice(0, 5)
      .map(v => ({
        vulnerability: v.category,
        action: v.remediation.steps[0] || 'Manual review required',
        priority: 'high'
      }));
  }

  getLongTermActions(vulnerabilities) {
    return vulnerabilities
      .filter(v => v.severity === 'medium')
      .slice(0, 10)
      .map(v => ({
        vulnerability: v.category,
        action: v.remediation.steps[0] || 'Manual review required',
        priority: 'medium'
      }));
  }

  estimateResourceRequirements(vulnerabilities) {
    const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
    const highCount = vulnerabilities.filter(v => v.severity === 'high').length;
    
    return {
      developerHours: (criticalCount * 8) + (highCount * 4),
      securityExpertHours: (criticalCount * 4) + (highCount * 2),
      testingHours: (criticalCount * 4) + (highCount * 2),
      totalCost: (criticalCount * 2000) + (highCount * 1000) // Estimated cost in USD
    };
  }

  generateRemediationTimeline(vulnerabilities) {
    const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
    const highCount = vulnerabilities.filter(v => v.severity === 'high').length;
    
    return {
      immediate: `Fix ${criticalCount} critical vulnerabilities within 7 days`,
      shortTerm: `Fix ${highCount} high severity vulnerabilities within 30 days`,
      longTerm: 'Address remaining vulnerabilities within 90 days'
    };
  }

  generateComplianceCheck(scanResults) {
    const vulnerabilities = scanResults.vulnerabilities;
    
    return {
      owaspTop10: this.checkOWASPCompliance(vulnerabilities),
      pciDss: this.checkPCIDSSCompliance(vulnerabilities),
      gdpr: this.checkGDPRCompliance(vulnerabilities),
      hipaa: this.checkHIPAACompliance(vulnerabilities),
      sox: this.checkSOXCompliance(vulnerabilities)
    };
  }

  checkOWASPCompliance(vulnerabilities) {
    const owaspCategories = new Set(Object.keys(this.vulnerabilityDatabase.owasp));
    const foundCategories = new Set(vulnerabilities.map(v => v.category));
    
    return {
      compliant: foundCategories.size === 0,
      affectedCategories: Array.from(foundCategories),
      recommendation: foundCategories.size > 0 ? 'Address OWASP Top 10 vulnerabilities' : 'Compliant'
    };
  }

  checkPCIDSSCompliance(vulnerabilities) {
    const pciRelevantVulns = vulnerabilities.filter(v => 
      ['sensitiveDataExposure', 'brokenAuthentication', 'injection'].includes(v.category)
    );
    
    return {
      compliant: pciRelevantVulns.length === 0,
      violations: pciRelevantVulns.length,
      recommendation: pciRelevantVulns.length > 0 ? 'Address PCI DSS relevant vulnerabilities' : 'Compliant'
    };
  }

  checkGDPRCompliance(vulnerabilities) {
    const gdprRelevantVulns = vulnerabilities.filter(v => 
      ['sensitiveDataExposure', 'brokenAccessControl'].includes(v.category)
    );
    
    return {
      compliant: gdprRelevantVulns.length === 0,
      violations: gdprRelevantVulns.length,
      recommendation: gdprRelevantVulns.length > 0 ? 'Address GDPR relevant vulnerabilities' : 'Compliant'
    };
  }

  checkHIPAACompliance(vulnerabilities) {
    const hipaaRelevantVulns = vulnerabilities.filter(v => 
      ['sensitiveDataExposure', 'brokenAuthentication', 'insufficientLogging'].includes(v.category)
    );
    
    return {
      compliant: hipaaRelevantVulns.length === 0,
      violations: hipaaRelevantVulns.length,
      recommendation: hipaaRelevantVulns.length > 0 ? 'Address HIPAA relevant vulnerabilities' : 'Compliant'
    };
  }

  checkSOXCompliance(vulnerabilities) {
    const soxRelevantVulns = vulnerabilities.filter(v => 
      ['insufficientLogging', 'brokenAccessControl'].includes(v.category)
    );
    
    return {
      compliant: soxRelevantVulns.length === 0,
      violations: soxRelevantVulns.length,
      recommendation: soxRelevantVulns.length > 0 ? 'Address SOX relevant vulnerabilities' : 'Compliant'
    };
  }

  // Utility functions
  generateScanId() {
    return crypto.randomBytes(16).toString('hex');
  }

  parseFileSize(sizeStr) {
    const units = { b: 1, kb: 1024, mb: 1024 * 1024, gb: 1024 * 1024 * 1024 };
    const match = sizeStr.toLowerCase().match(/^(\d+)(\w+)$/);
    if (!match) return 1024 * 1024; // Default 1MB
    
    const size = parseInt(match[1]);
    const unit = match[2];
    
    return size * (units[unit] || 1);
  }

  getScanResults(scanId) {
    return this.scanResults.get(scanId);
  }

  getAllScanResults() {
    return Array.from(this.scanResults.values());
  }

  // Cleanup old scan results
  cleanup() {
    const maxAge = 30 * 24 * 60 * 60 * 1000; // 30 days
    const now = Date.now();
    
    for (const [scanId, results] of this.scanResults.entries()) {
      if (now - results.endTime > maxAge) {
        this.scanResults.delete(scanId);
      }
    }
    
    logger.info('Vulnerability scanner cleanup completed');
  }
}

module.exports = VulnerabilityScannerService;